#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -* vim: syntax=python -*-
'''
hurry – 💨 Your command is my objective 💨
'''

import glob
import json
import logging
import os
import shutil
import subprocess
import sys
import tempfile
from string import Template
import coloredlogs
import fire
import yaml
from art import tprint
from InquirerPy import prompt
from InquirerPy.validator import NumberValidator

logging.basicConfig(format='= HURRY = %(levelname)s: %(message)s',
                    level=logging.DEBUG)
logger = logging.getLogger(__name__)
coloredlogs.install(level=logging.DEBUG, logger=logger)


class Hurry():
    '''
    💨 Your command is my objective 💨

    CLI Tool for setting up a Freqtrade instance containing the MGM strategy
    '''

    config = []

    def __init__(self):
        tprint("hurry cli")

        self._basedir = os.getcwd()

        self.__reload_config()
        self.__init_freqtrade()
        self.__init_mgm()

    def __reload_config(self) -> bool:
        self.config = None

        if os.path.exists(".hurry") is True:
            self.config = self.__read_config()
            return True

        return False

    def __init_freqtrade(self) -> bool:
        '''
        Initializes the Freqtrade binary

        Returns:
            bool: True if freqtrade installation is found. False otherwise.
        '''

        if os.path.exists(f"{self._basedir}/.env/bin/freqtrade") is False:
            logger.warning('🤷‍♂️ No freqtrade installation found.')
            return False

        if self.config is None:
            return False

        if self.config['install_type'] == "source":
            self.config[
                'ft_binary'] = f"source {self._basedir}/.env/bin/activate; freqtrade"
        else:
            self.config['ft_binary'] = "docker-compose run --rm freqtrade"

        logger.debug(f"👉 Freqtrade binary: `{self.config['ft_binary']}`")

        return True

    def __init_mgm(self) -> bool:
        '''
        Checks if MGM exists

        Returns:
            bool: True if MGM config and strategy file is found. False otherwise.
        '''

        if os.path.exists(
                f"{self._basedir}/user_data/mgm-config.json") is False:
            logger.warning('🤷‍♂️ No MGM installation found.')
            return False

        if os.path.exists(
                f"{self._basedir}/user_data/strategies/MoniGoManiHyperStrategy.py"
        ) is False:
            logger.warning('🤷‍♂️ No MGM installation found.')
            return False

        logger.debug('👉 MGM strategy and config found √')

        return True

    def up(self):  # pylint: disable=invalid-name
        '''The all in one command. Hurry up, turn it up!'''

        questions = [
            {
                "type": "confirm",
                "name": "install_freqtrade",
                "message": "💨 Do you want to install Freqtrade?"
            },
            {
                "type": "confirm",
                "name": "install_mgm",
                "message": "💨 Do you want to install MGM?"
            },
            {
                "type": "confirm",
                "name": "run_setup",
                "message": "💨 Do you want to configure it now?"
            },
            {
                "type": "confirm",
                "name": "download_data",
                "message": "💨 Do you want to download candle data now?"
            },
            {
                "type": "confirm",
                "name": "download_static_pairlist",
                "message": "💨 Do you want to generate a static pairlist now?"
            },
            {
                "type": "confirm",
                "name": "do_hyperopt",
                "message": "💨 Do you want to hyperopt now?"
            },
            {
                "type": "confirm",
                "name": "do_backtest",
                "message": "💨 Do you want to backtest now?"
            },
            {
                "type":
                "list",
                "name":
                "start_trading",
                "message":
                "💨 Do you want to start trading?",
                "choices": [{
                    "name": "No",
                    "value": 0
                }, {
                    "name": "Yes, Dry-Run please",
                    "value": 1
                }, {
                    "name": "Yes, for real!",
                    "value": 2
                }]
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        if answers.get('install_freqtrade') is True:
            self.install_freqtrade()

        if answers.get('install_mgm') is True:
            self.install_mgm()

        if answers.get('run_setup') is True:
            self.setup()

        if answers.get('download_data') is True:
            self.download_candle_data()

        if answers.get('download_static_pairlist') is True:
            self.download_static_pairlist()

        if answers.get('do_hyperopt') is True:
            # First HO run
            self.hyperopt()
            ho_choice = prompt(questions=[{
                "type": "input",
                "name": "ho_epoch",
                "message":
                "(HO 1) Choose the epoch which fits the best to your liking: (0-800) ",
                "filter": lambda val: int(val),
                "validate": NumberValidator()
            }])
            self.hyperopt_apply_epoch(ho_choice.get('ho_epoch'), 1)

            # Second HO run
            self.hyperopt()
            ho_choice = prompt(questions=[{
                "type": "input",
                "name": "ho_epoch",
                "message":
                "(HO 2) Choose the epoch which fits the best to your liking: (0-800) ",
                "filter": lambda val: int(val),
                "validate": NumberValidator()
            }])
            self.hyperopt_apply_epoch(ho_choice.get('ho_epoch'), 2)

        if answers.get('do_backtest') is True:
            self.backtest()

        if answers.get('start_trading') > 0:
            if answers.get('start_trading') == 2:
                self.start_trader(False)
            else:
                self.start_trader(True)
        else:
            logger.info('💨 Executing hurry up finished.')

    def install_freqtrade(self,
                          branch: str = "develop",
                          target_dir: str = None):
        '''Install Freqtrade the easy way.

        Args:
            branch (string, optional): Checkout a specific branch. Defaults to main.
            target_dir (string, optional): Specify a target_dir to install to.
                                            Defaults to os.getcwd().

        Todo:
            * Check if freqtrade was installed already and warn user it will be overwritten.
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Install Freqtrade ')
        logger.info('💨 💨 💨')

        if target_dir is None:
            target_dir = self._basedir

        with tempfile.TemporaryDirectory() as tmpdirname:
            self.__exec_cmd(
                f"git clone -b {branch} https://github.com/freqtrade/freqtrade.git {tmpdirname}"
            )

            self.__exec_cmd(f'cp -rf {tmpdirname}/* {target_dir}')

            self.__exec_cmd(
                f'deactivate; bash {target_dir}/setup.sh --install')

            logger.info(
                '🍺 Freqtrade has been installed. You can now proceed to install MGM. (Hint: hurry install_mgm)'
            )

    def install_mgm(self, branch: str = "development", target_dir: str = None):
        '''Install the MGM strategy.

        Args:
            branch (str, optional): Git-branch to install. Defaults to "development".
            target_dir (str, optional): Target directory to install MGM. Defaults to os.getcwd().

        Todo:
            * Check if MGM was installed already and warn user it will be overwritten.
            * Probably merge mgm-config-private.json into new installation?
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Install MGM ')
        logger.info('💨 💨 💨')

        if target_dir is None:
            target_dir = self._basedir

        with tempfile.TemporaryDirectory() as tmpdirname:
            self.__exec_cmd(
                f"git clone -b {branch} https://github.com/Rikj000/MoniGoMani.git {tmpdirname}"
            )

            self.__exec_cmd(
                f'cp -rf {tmpdirname}/user_data/* {target_dir}/user_data/')

            self.__create_mgm_config_files(target_dir)

            logger.info(
                '🍺 MGM has been installed. You can now proceed to setup your instance. (Hint: hurry setup)'
            )

    @staticmethod
    def __create_mgm_config_files(target_dir: str):
        '''
        Copy example files as def files.

        Args:
            target_dir (string): The target dir where the mgm-config.example.json exists.
        '''
        if os.path.exists(f'{target_dir}/user_data/mgm-config.json') is False:
            shutil.copyfile(f'{target_dir}/user_data/mgm-config.example.json',
                            f'{target_dir}/user_data/mgm-config.json')

        if os.path.exists(
                f'{target_dir}/user_data/mgm-config-private.json') is False:
            shutil.copyfile(
                f'{target_dir}/user_data/mgm-config-private.example.json',
                f'{target_dir}/user_data/mgm-config-private.json')

        logger.warning(f'{target_dir}/user_data/mgm-config.json')

    def setup(self):
        '''
        Saves setup data based on your answers

        Todo:
            - Populate default values based on .hurry config
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Setup ')
        logger.info('💨 💨 💨')

        logger.info("🤓 Let's answer some questions to make our lifes easier.")

        strategies = map(
            lambda f: os.path.basename(f).replace(".py", ""),
            glob.glob(self._basedir + "/user_data/strategies/*.py"))

        strategies_choices = []
        for strat in strategies:
            if strat != "MasterMoniGoManiHyperStrategy":
                strategies_choices.append({"name": strat, "value": strat})

        if len(strategies_choices) == 0:
            strat_dir = self._basedir + "/user_data/strategies/"
            logger.error(
                f"🤷‍♂️ I could not find any strategy in {strat_dir}. Did you install Freqtrade and MGM?"
            )
            sys.exit(1)

        self.__create_mgm_config_files(self._basedir)

        hyperopts = map(lambda f: os.path.basename(f).replace(".py", ""),
                        glob.glob(self._basedir + "/user_data/hyperopts/*.py"))

        hyperopts_choices = []
        for hyperopt in hyperopts:
            hyperopts_choices.append({"name": hyperopt, "value": hyperopt})

        if len(hyperopts_choices) == 0:
            ho_dir = self._basedir + "/user_data/hyperopts/"
            logger.error(
                f"🤷‍♂️ I could not find any hyperopts in {ho_dir}. Did you install Freqtrade and MGM?"
            )
            sys.exit(1)

        questions = [{
            "type": "list",
            "name": "install_type",
            "message": "Which way you want to use Freqtrade?",
            "choices": ["docker", "source"]
        }, {
            "type": "input",
            "name": "timerange",
            "message": "Please enter the default timerange you want to use",
            "default": "20201201-20210316"
        }, {
            "type": "list",
            "name": "ho_strategy",
            "message": "Which HyperOpt Strategy do you want to use?",
            "choices": strategies_choices
        }, {
            "type": "list",
            "name": "ho_loss",
            "message": "Which HyperOpt Loss do you want to use?",
            "choices": hyperopts_choices
        }, {
            "type":
            "checkbox",
            "name":
            "ho_spaces",
            "message":
            "Which spaces do you want to HyperOpt?",
            "choices":
            ["default", "buy", "sell", "roi", "stoploss", "trailing", "all"],
            "filter":
            lambda val: " ".join(val)
        }, {
            "type": "input",
            "name": "ho_quotation",
            "message": "Please enter the default quotation you want to use",
            "default": "BTC"
        }, {
            "type": "input",
            "name": "ho_epochs",
            "message":
            "Please enter the amount of epochs you want to HyperOpt",
            "default": "800",
            "filter": lambda val: int(val)
        }, {
            "type": "confirm",
            "message": "Do you want to also setup your exchange?",
            "name": "proceed_exchange",
            "default": True,
        }, {
            "type": "list",
            "name": "exchange",
            "message": "Which exchange do you want to use?",
            "choices": ["binance", "ftx", "bittrex"],
            "when": lambda result: result["proceed_exchange"]
        }, {
            "type": "password",
            "name": "api_key",
            "message": "Please enter the exchange API key",
            "when": lambda result: result["proceed_exchange"]
        }, {
            "type": "password",
            "name": "api_secret",
            "message": "Please enter the exchange API secret: ",
            "when": lambda result: result["proceed_exchange"]
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit(0)

        newconfig = {
            'config': {
                'install_type': answers.get('install_type'),
                'timerange': answers.get('timerange'),
                'exchange': answers.get('exchange'),
                'hyperopt': {
                    'strategy': answers.get('ho_strategy'),
                    'loss': answers.get('ho_loss'),
                    'spaces': answers.get('ho_spaces'),
                    'quote': answers.get('ho_quotation'),
                    'epochs': answers.get('ho_epochs')
                }
            }
        }

        self.__write_config(newconfig)
        self.__reload_config()

        if answers.get('proceed_exchange') is True:
            cred = {
                'exchange': answers.get('exchange'),
                'api_key': answers.get('api_key'),
                'api_secret': answers.get('api_secret'),
            }

            self._save_exchange_credentials(cred)

        self.__setup_telegram()

    def cleanup(self):
        '''
        Deletes stored hyperopt config from previous run(s)
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Cleanup ')
        logger.info('💨 💨 💨')

        logger.info('👉 Removing user_data/mgm-config-hyperopt.json')

        ho_file = f"{self._basedir}/user_data/mgm-config-hyperopt.json"

        if os.path.exists(ho_file):
            os.remove(ho_file)

        logger.info('🍺 HyperOpt config removed.')

    def download_candle_data(self, timerange: str = None):
        '''
        Downloads candle data for the given timerange.

        Args:
            timerange (str, Optional): Timerange from/to in string format (start-end):
                                        yyyymmdd-yyyymmdd. Defaults to timerange out of
                                        .hurry config file.
                                    -or- for preset timerange: down, side, up
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Download candle data ')
        logger.info('💨 💨 💨')

        if self.__reload_config() is False:
            logger.error('No Hurry config file found. Please run: hurry setup')
            sys.exit(0)

        timerange = self.__get_preset_timerange(timerange)

        self.__init_freqtrade()

        questions = [{
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the timerange you want to use: ',
            'default': timerange
        }, {
            'type':
            'checkbox',
            'name':
            'tickers',
            'message':
            'Specify which tickers to download: ',
            'choices': [
                {
                    'name': '1m',
                    'value': '1m',
                    'enabled': False
                },
                {
                    'name': '3m',
                    'value': '3m',
                    'enabled': False
                },
                {
                    'name': '5m',
                    'value': '5m',
                    'enabled': True
                },
                {
                    'name': '15m',
                    'value': '15m',
                    'enabled': False
                },
                {
                    'name': '30m',
                    'value': '30m',
                    'enabled': False
                },
                {
                    'name': '1h',
                    'value': '1h',
                    'enabled': True
                },
                {
                    'name': '2h',
                    'value': '2h',
                    'enabled': False
                },
                {
                    'name': '4h',
                    'value': '4h',
                    'enabled': False
                },
                {
                    'name': '6h',
                    'value': '6h',
                    'enabled': False
                },
                {
                    'name': '8h',
                    'value': '8h',
                    'enabled': False
                },
                {
                    'name': '12h',
                    'value': '12h',
                    'enabled': False
                },
                {
                    'name': '1d',
                    'value': '1d',
                    'enabled': False
                },
                {
                    'name': '3d',
                    'value': '3d',
                    'enabled': False
                },
                {
                    'name': '1w',
                    'value': '1w',
                    'enabled': False
                },
                {
                    'name': '2w',
                    'value': '2w',
                    'enabled': False
                },
                {
                    'name': '1M',
                    'value': '1M',
                    'enabled': False
                },
                {
                    'name': '1y',
                    'value': '1y',
                    'enabled': False
                },
            ],
            'validate':
            lambda result: len(result) >= 1,
            'invalid_message':
            'should be at least 1 selection',
            'instruction':
            '(select at least 1)',
            'filter':
            lambda val: " ".join(val)
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        timerange = answers.get('timerange')
        tickers = answers.get('tickers')

        logger.info(
            f'👉 Downloading candle data ({tickers}) for timerange {timerange}')

        dcd = f"{self.config['ft_binary']} download-data --timerange {timerange} \
            -t {tickers} -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json"

        self.__exec_cmd(dcd)

        logger.info('🍺 Downloading candle data finished.')

    def download_static_pairlist(self):
        '''
        Downloads static pairlist and saves into mgm_pair_lists folder.

        Fixme:
            * Temporary disabled due to nasty bug
            && jq 'del(.exchange.pair_whitelist )' ./user_data/mgm-config.json > ./tmp.json && jq -s '.[0] * .[1]'
                ./tmp.json ./user_data/mgm_pair_lists/$exchange-$hyperopt_quote-Top-Volume-StaticPairList.json >
                ./user_data/mgm-config.json && rm ./tmp.json && jq '.' ./user_data/mgm-config.json"
            * Catch errors

        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Computing Top Volume Static Pairlist')
        logger.info('💨 💨 💨')

        target_file = '$basedir/user_data/mgm_pair_lists/$exchange-$hyperopt_quote-Top-Volume-StaticPairList.json'
        target_file = Template(target_file).substitute(
            basedir=self._basedir,
            exchange=self.config['exchange'].title(),
            hyperopt_quote=self.config['hyperopt']['quote'])

        cmd_str = "$ft_binary test-pairlist -c ./user_data/mgm_tools/$exchange-Retrieve-Top-Volume-StaticPairList.json \
            --quote $hyperopt_quote --print-json | tail -n 1 | jq '.| $exchange_placeholder' > $target_file"

        cmd_str = Template(cmd_str).substitute(
            ft_binary=self.config['ft_binary'],
            exchange=self.config['exchange'].title(),
            hyperopt_quote=self.config['hyperopt']['quote'],
            exchange_placeholder="{exchange: {pair_whitelist: .}}",
            target_file=target_file)

        self.__exec_cmd(cmd_str)

        logger.info(" 🍺 Writing pairlist to mgm-config.json... ")

        # Copy static pairlist to mgm-config.json as pair whitelist
        # Todo:
        # * Use with for resource-allocating operations
        static_pairlist = open(
            self._basedir +
            '/user_data/mgm_pair_lists/Binance-USDT-Top-Volume-StaticPairList.json',
        )
        mgm_config_json = json.load(static_pairlist)

        mgm_config = open(self._basedir + '/user_data/mgm-config.json', )
        mgm_config_data = json.load(mgm_config)

        mgm_config_data['exchange']['pair_whitelist'] = mgm_config_json[
            'exchange']['pair_whitelist']

        with open(self._basedir + '/user_data/mgm-config.json',
                  'w') as target_f:
            json.dump(mgm_config_data, target_f, indent=4)

        # logger.error("🤷‍♂️ Something happened on the way to heaven 🌟🤦‍♀️")

    def hyperopt(self,
                 timerange: str = None,
                 strategy: str = None,
                 spaces: str = None):
        '''
        HyperOpt Magic. Runs HyperOpt process to find out the most positive settings.

        Args:
            timerange (str, Optional): timerange from/to in format (start-end): yyyymmdd-yyyymmdd or preset [up, down, side]
            strategy (str, Optional): Hyper Opt strategy to use. Defaults to MoniGoManiHyperStrategy
            spaces (str, Optional): Spaces (space delimited) to optimize for [default, all, buy, sell, roi, stoploss, etc]
        '''
        logger.info('💨 💨 💨')
        logger.info(
            '👉 Starting HyperOpt run. Keep calm while your computer burns 🔥')
        logger.info('💨 💨 💨')

        timerange = self.__get_preset_timerange(timerange)

        if strategy is None:
            strategy = self.config['hyperopt']['strategy']

        if spaces is None:
            spaces = self.config['hyperopt']['spaces']

        cmd = (
            '$ft_binary hyperopt --print-all -s $ho_strategy '
            '-c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json '
            '--hyperopt-loss $ho_loss --spaces $ho_spaces -e $ho_epochs --timerange $timerange'
        )
        cmd = Template(cmd).substitute(
            ft_binary=self.config['ft_binary'],
            ho_strategy=strategy,
            ho_loss=self.config['hyperopt']['loss'],
            ho_spaces=spaces,
            ho_epochs=self.config['hyperopt']['epochs'],
            timerange=timerange)

        self.__exec_cmd(cmd)

        logger.info('🍺 HyperOpt run ready... 🥵')

    def hyperopt_show_results(self,
                              only_best: bool = True,
                              only_profitable: bool = False):
        '''
        Show hyperopt results after choosing a fthypt file.

        Args:
            only_best (bool, Optional); Show only best epochs. Defaults to True.
            only_profitable (bool, Optional); Show only profitable epochs. Defaults to False.

        Todo:
            * Sort fthypt-files based on date (newest - oldest)
            * Pass through additional (optional) arguments to freqtrade cli
        '''

        fthypts = map(
            os.path.basename,
            glob.glob(self._basedir + '/user_data/hyperopt_results/*.fthypt'))

        dat = list(fthypts)

        if len(dat) == 0:
            logger.warning('Whoops, no hyperopt results could be found.')
            sys.exit(1)

        questions = [
            {
                'type': 'list',
                'name': 'fthypt_file',
                'message':
                'Please select the hyperopt results you want to show: ',
                'choices': dat
            },
        ]

        answers = prompt(questions=questions)

        choice = answers.get('fthypt_file')

        logger.info("👉 Showing hyperopt results for: %(choice)s:" + choice)

        best = "--best" if only_best is True else ""
        profit = "--profitable" if only_profitable is True else ""

        dcd = f"{self.config['ft_binary']} hyperopt-list --hyperopt-filename '{choice}' {best} {profit}"
        logger.debug(dcd)

        self.__exec_cmd(dcd)

    def hyperopt_show_epoch(self, epoch: int = 0):
        '''
        Shows the HyperOpt results for given epoch.

        Args:
            epoch (int): The epoch number to show the results from.
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Hyperopt show results ')
        logger.info('💨 💨 💨')

        if epoch == 0:
            logger.error(
                '🤷‍♂️ Please pass the epoch number through. Hint: hurry hyperopt_show_epoch --epoch=1337'
            )
            sys.exit(1)

        logger.info('👉  Showing HyperOpt results for epoch # {epoch}')

        self.__exec_cmd(f"{self.config['ft_binary']} hyperopt-show -n {epoch}")

    def hyperopt_apply_epoch(self, epoch: int = 0, run: int = 1):
        '''Apply HyperOpt results from given epoch

        Args:
            epoch (int): The epoch number to apply the results from.
            run (int, Optional): Defaults to 1. Run number of hyperopt.
                                First run has different command than second.
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Hyperopt apply epoch ')
        logger.info('💨 💨 💨')

        if epoch == 0:
            logger.error(
                '🤷‍♂️ Please pass the epoch number through. Hint: hurry hyperopt_apply_epoch --epoch=1337'
            )
            sys.exit(1)

        logger.info(f'👉 Applying HyperOpt results of epoch # {epoch}')

        if run == 1:
            self.__exec_cmd((
                f"{self.config['ft_binary']} hyperopt-show -n {epoch} "
                "-c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json "
                "--no-header --print-json | tail -n 1 | jq '.' > ./user_data/mgm-config-hyperopt.json"
            ))
        else:
            self.__exec_cmd((
                f"{self.config['ft_binary']} hyperopt-show -n {epoch} "
                "-c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json "
                "--no-header --print-json | tail -n 1 | jq '.' > ./tmp.json && "
                "jq -s '.[0] * .[1]' ./user_data/mgm-config-hyperopt.json ./tmp.json > ./tmp2.json && "
                "rm ./tmp.json ./user_data/mgm-config-hyperopt.json && "
                "mv ./tmp2.json ./user_data/mgm-config-hyperopt.json && jq '.' ./user_data/mgm-config-hyperopt.json"
            ))

        logger.info(f'🍺 Hyperopt results of epoch # {epoch} are applied.')

    def backtest(self, timerange: str = None, enable_protections: bool = True):
        '''
        Run a backtest session.

        Args:
            timerange (string, Optional): The target timerange for backtesting. Defaults to None.
            enable_protections (bool, Optional): Whether or not to enable protections. Defaults to True.
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Start backtesting. Lets see how it all turns out!')
        logger.info('💨 💨 💨')

        timerange = self.__get_preset_timerange(timerange)

        cmd = (
            '$ft_binary backtesting -s $ho_strategy '
            '-c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json '
            '--timerange $timerange')

        if enable_protections is True:
            cmd = cmd + " --enable-protections"

        cmd = Template(cmd).substitute(
            ft_binary=self.config['ft_binary'],
            ho_strategy=self.config['hyperopt']['strategy'],
            timerange=timerange)

        self.__exec_cmd(cmd)

        logger.info('🍺 Backtesting ready... 🤑')

    def start_trader(self, dry_run: bool = False):
        '''
        Start the trader. Your ultimate goal!

        Args:
            dry_run (bool, Optional): Use dry_run mode. Defaults to False
        '''
        logger.info('💨 💨 💨')
        logger.info('👉 Start trader ')
        logger.info('💨 💨 💨')

        cmd = (
            f"{self.config['ft_binary']} trade "
            "-c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json "
            "-c ./user_data/mgm-config-hyperopt.json --strategy {self.config['hyperopt']['strategy']}"
        )

        if dry_run is True:
            cmd = cmd + " --dry-run"

        self.__exec_cmd(cmd)

    def __setup_telegram(self) -> bool:
        '''
        Questionnaire to setup Telegram Bot

        Returns:
            bool: False if no answers are given, True if all went ok.
        '''
        questions = [
            {
                "type": "confirm",
                "message": "Do you want to also setup your Telegram bot? ",
                "name": "proceed_telegram",
                "default": True,
            },
            {
                "type": "confirm",
                "message": "Do you want to enable the Telegram Bot?",
                "name": "enable_telegram",
                "default": True,
                "when": lambda result: result["proceed_telegram"]
            },
            {
                "type":
                "password",
                "name":
                "telegram_token",
                "message":
                "Please enter your Telegram Bot token: ",
                "default":
                "",
                "when":
                lambda result: result["proceed_telegram"] and result[
                    "enable_telegram"]
            },
            {
                "type":
                "input",
                "name":
                "telegram_chat_id",
                "message":
                "Please enter the chat ID: ",
                "default":
                "",
                "when":
                lambda result: result["proceed_telegram"] and result[
                    "enable_telegram"]
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            return False

        if answers.get('proceed_telegram') is True:
            opt = {
                'enable_telegram': answers.get('enable_telegram'),
                'telegram_token': answers.get('telegram_token'),
                'telegram_chat_id': answers.get('telegram_chat_id')
            }

            self._save_telegram_credentials(opt)

        return True

    def _save_exchange_credentials(self, cred: dict):
        '''
        Save exchange credentials to mgm-config-private.json

        Args:
            cred (dict) - list containing values for [exchange,api_key,api_secret]
        '''
        file = open(self._basedir + '/user_data/mgm-config-private.json', 'w+')

        try:
            data = json.load(file)
        except:  # pylint: disable=bare-except
            data = {}

        data['exchange'] = {
            "name": cred['exchange'],
            "key": cred['api_key'],
            "secret": cred['api_secret']
        }

        with open(self._basedir + '/user_data/mgm-config-private.json',
                  'w+') as outfile:
            json.dump(data, outfile, indent=4)

        logger.info("🍺 Exchange settings written to mgm-config-private.json")

    def _save_telegram_credentials(self, opt: dict):
        '''
        Save Telegram bot settings

        Args:
            opt (dict): list containing values for [enable_telegram,telegram_token,telegram_chat_id]
        '''
        file = open(self._basedir + '/user_data/mgm-config-private.json', )

        data = json.load(file)

        data['telegram'] = {
            "enabled": opt['enable_telegram'],
            "token": opt['telegram_token'],
            "chat_id": opt['telegram_chat_id']
        }

        with open(self._basedir + '/user_data/mgm-config-private.json',
                  'w') as outfile:
            json.dump(data, outfile, indent=4)

        logger.info(
            "🍺 Telegram bot settings written to mgm-config-private.json")

    def __get_preset_timerange(self, timerange: str) -> str:
        '''
        Parses given timerange-string into according timerange dates

        Args:
            timerange (str): the timerange-string to parse [up, down, side]

        Returns:
            timerange (str): the parsed timerange string in yyyymmdd-yyyymmdd format
        '''

        input = timerange

        if timerange is None:
            timerange = self.config['timerange']

        if timerange == "down":
            timerange = '20210509-20210524'

        if timerange == "side":
            timerange = '20210518-20210610'

        if timerange == "up":
            timerange = '20210127-20210221'

        output = timerange

        logger.info(f'☀️ Timerange string parsed from "{input}" to "{output}"')

        return timerange

    @staticmethod
    def __exec_cmd(cmd: str) -> int:
        '''
        Executes shell command and logs output as debug output.

        Args:
            cmd (str): The command, sir

        Returns:
            returncode (int): The returncode of the subprocess
        '''
        if cmd is None or cmd == "":
            logger.error(
                '🤷‍♂️ Please pass a command through. Without command no objective, sir!'
            )
            sys.exit(1)

        process = subprocess.Popen(cmd,
                                   shell=True,
                                   stdout=subprocess.PIPE,
                                   encoding='utf-8')

        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break

            if output:
                print(output.strip())

        retcode = process.poll()
        return retcode

    @staticmethod
    def __read_config():
        '''
        Reads config values out of .hurry config file.

        Returns:
            config (dict): Dictionary containing all config key/value pairs. Or returns None.
        '''
        with open(".hurry", "r") as ymlfile:
            cfg = yaml.full_load(ymlfile) or {}

        if 'config' in cfg:
            return cfg['config']

        return None

    def __write_config(self, config: dict = None):
        '''Write config-array to .hurry config file. Hooray!

        Args:
            config (object, Optional): The config values to store. Defaults to None.
        '''
        if config is None:
            config = {
                'config': {
                    'install_type': 'docker',
                    'timerange': '20201201-20210316',
                    'exchange': 'binance',
                    'hyperopt': {
                        'strategy': 'MoniGoManiHyperStrategy',
                        'loss': 'UncloggedWinRatioAndProfitRatioLoss',
                        'spaces': 'buy sell',
                        'quote': 'BTC',
                        'epochs': 800
                    }
                }
            }

        with open(r'.hurry', 'w') as file:
            yaml.dump(config, file)

        self.__reload_config()

        logger.info("🍺 Configuration data written to .hurry file")


if __name__ == "__main__":
    try:
        fire.Fire(Hurry)
    except KeyboardInterrupt:
        print('😼 KTHXBAI')
        sys.exit(0)
