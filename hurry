#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -* vim: syntax=python -*-

'''

hurry ‚Äì üí® Your command is my objective üí®

'''

from ctypes import Array
import glob
import json
import coloredlogs, logging
import os
import subprocess
import sys
import tempfile
from operator import add
from string import Template

import fire
import yaml
from art import tprint
from InquirerPy import prompt

logging.basicConfig(format='= HURRY = %(levelname)s: %(message)s',
                    level=logging.DEBUG)
logger = logging.getLogger(__name__)
coloredlogs.install(level=logging.DEBUG, logger=logger)


class Hurry():
    '''
    üí® Your command is my objective üí®

    CLI Tool for setting up a Freqtrade instance containing the MGM strategy
    '''

    config = []

    def __init__(self):
        tprint("hurry cli")

        self.config = None
        self._basedir = os.getcwd()

        if os.path.exists(".hurry") is True:
            self.config = self.__read_config()

        self.__init_freqtrade()
        self.__init_mgm()

    def __init_freqtrade(self) -> bool:
        '''
        Initializes the Freqtrade binary

        Returns:
            bool: True if freqtrade installation is found. False otherwise.
        '''

        if os.path.exists(f"{self._basedir}/.env/bin/freqtrade") is False:
            logger.warning('ü§∑‚Äç‚ôÇÔ∏è No freqtrade installation found.')
            return False

        if self.config is None:
            return False

        if self.config['install_type'] == "source":
            self.config[
                'ft_binary'] = f"source {self._basedir}/.env/bin/activate; freqtrade"
        else:
            self.config['ft_binary'] = "docker-compose run --rm freqtrade"

        logger.debug(f"üëâ Freqtrade binary: `{self.config['ft_binary']}`")

        return True

    def __init_mgm(self) -> bool:
        '''
        Checks if MGM exists

        Returns:
            bool: True if MGM config and strategy file is found. False otherwise.
        '''

        if os.path.exists(f"{self._basedir}/user_data/mgm-config.json") is False:
            logger.warning('ü§∑‚Äç‚ôÇÔ∏è No MGM installation found.')
            return False

        if os.path.exists(f"{self._basedir}/user_data/strategies/MoniGoManiHyperStrategy.py") is False:
            logger.warning('ü§∑‚Äç‚ôÇÔ∏è No MGM installation found.')
            return False

        logger.debug('üëâ MGM strategy and config found ‚àö')

        return True

    def up(self):
        '''The all in one command. Hurry up, turn it up!'''

        questions = [
            {
                "type": "confirm",
                "name": "install_freqtrade",
                "message": "üí® Do you want to install Freqtrade?"
            },
            {
                "type": "confirm",
                "name": "install_mgm",
                "message": "üí® Do you want to install MGM?"
            },
            {
                "type": "confirm",
                "name": "run_setup",
                "message": "üí® Do you want to configure it now?"
            },
            {
                "type": "confirm",
                "name": "download_data",
                "message": "üí® Do you want to download candle data now?"
            },
            {
                "type": "confirm",
                "name": "download_static_pairlist",
                "message": "üí® Do you want to generate a static pairlist now?"
            },
            {
                "type": "confirm",
                "name": "do_hyperopt",
                "message": "üí® Do you want to hyperopt now?"
            },
            {
                "type": "confirm",
                "name": "do_backtest",
                "message": "üí® Do you want to backtest now?"
            },
            {
                "type": "list",
                "name": "start_trading",
                "message": "üí® Do you want to start trading?",
                "choices": [
                    {
                        "name": "No",
                        "value": 0
                    },
                    {
                        "name": "Yes, Dry-Run please",
                        "value": 1
                    },
                    {
                        "name": "Yes, for real!",
                        "value": 2
                    }
                ]
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        if answers.get('install_freqtrade') is True:
            self.install_freqtrade()

        if answers.get('install_mgm') is True:
            self.install_mgm()

        if answers.get('run_setup') is True:
            self.setup()

        if answers.get('download_data') is True:
            self.download_candle_data()

        if answers.get('download_static_pairlist') is True:
            self.download_static_pairlist()

        if answers.get('do_hyperopt') is True:
            self.hyperopt()

            ho_choice = prompt(questions=[{ "type": "input", "name": "ho_epoch", "message": "Choose the epoch which fits the best to your liking: (0-800) ", "filter": lambda val: int(val)}])
            self.hyperopt_apply_epoch(ho_choice.ansers.get('ho_epoch'))

        # TODO
        # - second ho run?

        if answers.get('do_backtest') is True:
            self.backtest()

        if answers.get('start_trading') > 0:
            if ( answers.get('start_trading') == 2 ):
                self.start_trader(False)
            else:
                self.start_trader(True)
        else:
            logger.info('üí® Executing hurry up finished.')

    def install_freqtrade(self,
                          branch: str = "develop",
                          target_dir: str = os.getcwd()):
        '''Install Freqtrade the easy way.

        Args:
            branch (string, optional): Checkout a specific branch. Defaults to main.
            target_dir (string, optional): Specify a target_dir to install to. Defaults to os.getcwd().

        Todo:
            * Check if freqtrade was installed already and warn user it will be overwritten.
        '''

        with tempfile.TemporaryDirectory() as tmpdirname:
            cmd_str = f"git clone -b {branch} https://github.com/freqtrade/freqtrade.git {tmpdirname}"
            self.__exec_cmd(cmd_str)
            self.__exec_cmd(f'cp -rf {tmpdirname}/* {target_dir}')
            self.__exec_cmd(
                f'deactivate; bash {target_dir}/setup.sh --install')

            logger.info(
                'üç∫ Freqtrade has been installed. You can now proceed to install MGM. (Hint: hurry install_mgm)'
            )

    def install_mgm(self,
                    branch: str = "development",
                    target_dir: str = os.getcwd()):
        '''Install the MGM strategy.

        Args:
            branch (str, optional): Git-branch to install. Defaults to "development".
            target_dir (str, optional): Target directory to install MGM. Defaults to os.getcwd().

        Todo:
            * Check if MGM was installed already and warn user it will be overwritten.
            * Probably merge mgm-config-private.json into new installation?
        '''

        with tempfile.TemporaryDirectory() as tmpdirname:
            cmd_str = f"git clone -b {branch} https://github.com/Rikj000/MoniGoMani.git {tmpdirname}"
            self.__exec_cmd(cmd_str)
            self.__exec_cmd(
                f'cp -rf {tmpdirname}/user_data/* {target_dir}/user_data/')

            logger.info(
                'üç∫ MGM has been installed. You can now proceed to setup your instance. (Hint: hurry setup)'
            )

    def setup(self):
        '''
        Saves setup data based on your answers
        '''
        logger.info("ü§ì Let's answer some questions to make our lifes easier;")

        strategies = map(
            lambda f: os.path.basename(f).replace(".py", ""),
            glob.glob(self._basedir + "/user_data/strategies/*.py"))

        strategies_choices = []
        for s in strategies:
            strategies_choices.append({"name": s, "value": s})

        if len(strategies_choices) == 0:
            strat_dir = self._basedir + "/user_data/strategies/"
            logger.error(
                f"ü§∑‚Äç‚ôÇÔ∏è I could not find any strategy in {strat_dir}. Did you install Freqtrade and MGM?"
            )
            sys.exit(1)

        hyperopts = map(lambda f: os.path.basename(f).replace(".py", ""),
                        glob.glob(self._basedir + "/user_data/hyperopts/*.py"))

        hyperopts_choices = []
        for s in hyperopts:
            hyperopts_choices.append({"name": s, "value": s})

        if len(hyperopts_choices) == 0:
            ho_dir = self._basedir + "/user_data/hyperopts/"
            logger.error(
                f"ü§∑‚Äç‚ôÇÔ∏è I could not find any hyperopts in {ho_dir}. Did you install Freqtrade and MGM?"
            )
            sys.exit(1)

        questions = [{
            "type": "list",
            "name": "install_type",
            "message": "Which way you want to use Freqtrade?",
            "choices": ["docker", "source"]
        }, {
            "type": "input",
            "name": "timerange",
            "message": "Please enter the default timerange you want to use",
            "default": "20201201-20210316"
        }, {
            "type": "list",
            "name": "ho_strategy",
            "message": "Which HyperOpt Strategy do you want to use?",
            "choices": strategies_choices
        }, {
            "type": "list",
            "name": "ho_loss",
            "message": "Which HyperOpt Loss do you want to use?",
            "choices": hyperopts_choices
        }, {
            "type":
            "checkbox",
            "name":
            "ho_spaces",
            "message":
            "Which spaces do you want to HyperOpt?",
            "choices":
            ["default", "buy", "sell", "roi", "stoploss", "trailing", "all"],
            "filter":
            lambda val: " ".join(val)
        }, {
            "type": "input",
            "name": "ho_quotation",
            "message": "Please enter the default quotation you want to use",
            "default": "BTC"
        }, {
            "type": "input",
            "name": "ho_epochs",
            "message":
            "Please enter the amount of epochs you want to HyperOpt",
            "default": "800",
            "filter": lambda val: int(val)
        }, {
            "type": "confirm",
            "message": "Do you want to also setup your exchange?",
            "name": "proceed_exchange",
            "default": True,
        }, {
            "type": "list",
            "name": "exchange",
            "message": "Which exchange do you want to use?",
            "choices": ["binance", "ftx", "bittrex"],
            "when": lambda result: result["proceed_exchange"]
        }, {
            "type": "password",
            "name": "api_key",
            "message": "Please enter the exchange API key",
            "when": lambda result: result["proceed_exchange"]
        }, {
            "type": "password",
            "name": "api_secret",
            "message": "Please enter the exchange API secret: ",
            "when": lambda result: result["proceed_exchange"]
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            exit()

        newconfig = {
            'config': {
                'install_type': answers.get('install_type'),
                'timerange': answers.get('timerange'),
                'exchange': answers.get('exchange'),
                'hyperopt': {
                    'strategy': answers.get('ho_strategy'),
                    'loss': answers.get('ho_loss'),
                    'spaces': answers.get('ho_spaces'),
                    'quote': answers.get('ho_quotation'),
                    'epochs': answers.get('ho_epochs')
                }
            }
        }

        self.__write_config(newconfig)

        if answers.get('proceed_exchange') is True:
            cred = {
                'exchange': answers.get('exchange'),
                'api_key': answers.get('api_key'),
                'api_secret': answers.get('api_secret'),
            }

            self._save_exchange_credentials(cred)

        self.__setup_telegram()

    def cleanup(self):
        '''
        Deletes stored hyperopt config from previous run(s)
        '''
        logger.info('üëâ Removing user_data/mgm-config-hyperopt.json')

        ho_file = f"{self._basedir}/user_data/mgm-config-hyperopt.json"

        if os.path.exists(ho_file):
            os.remove(ho_file)

        logger.info('üç∫ HyperOpt config removed.')

    def download_candle_data(self, timerange: str = None):
        '''
        Downloads candle data for the given timerange.

        Args:
            timerange (str, Optional): Timerange from/to in string format (start-end): yyyymmdd-yyyymmdd. Defaults to timerange out of .hurry config file.
        '''
        if timerange is None:
            timerange = self.config['timerange']

        questions = [{
            'type': 'input',
            'name': 'timerange',
            'message': 'Please enter the timerange you want to use',
            'default': self.config['timerange']
        }, {
            'type':
            'checkbox',
            'name':
            'tickers',
            'message':
            'Specify which tickers to download',
            'choices': [
                {
                    'name': '1m',
                    'value': '1m'
                },
                {
                    'name': '3m',
                    'value': '3m'
                },
                {
                    'name': '5m',
                    'value': '5m'
                },
                {
                    'name': '15m',
                    'value': '15m'
                },
                {
                    'name': '30m',
                    'value': '30m'
                },
                {
                    'name': '1h',
                    'value': '1h'
                },
                {
                    'name': '2h',
                    'value': '2h'
                },
                {
                    'name': '4h',
                    'value': '4h'
                },
                {
                    'name': '6h',
                    'value': '6h'
                },
                {
                    'name': '8h',
                    'value': '8h'
                },
                {
                    'name': '12h',
                    'value': '12h'
                },
                {
                    'name': '1d',
                    'value': '1d'
                },
                {
                    'name': '3d',
                    'value': '3d'
                },
                {
                    'name': '1w',
                    'value': '1w'
                },
                {
                    'name': '2w',
                    'value': '2w'
                },
                {
                    'name': '1M',
                    'value': '1M'
                },
                {
                    'name': '1y',
                    'value': '1y'
                },
            ],
            'filter':
            lambda val: " ".join(val)
        }]

        answers = prompt(questions=questions)

        if answers == {}:
            sys.exit()

        timerange = answers.get('timerange')
        tickers = answers.get('tickers')

        logger.info(
            f"üëâ Downloading candle data ({tickers}) for timerange {timerange}")

        dcd = f"{self.config['ft_binary']} download-data --timerange {timerange} \
            -t {tickers} -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json"

        self.__exec_cmd(dcd)

        logger.info('üç∫ Downloading candle data finished.')

    def download_static_pairlist(self):
        '''
        Downloads static pairlist and saves into mgm_pair_lists folder.

        Fixme:
            * temporary disabled due to nasty bug
            && jq 'del(.exchange.pair_whitelist )' ./user_data/mgm-config.json > ./tmp.json && jq -s '.[0] * .[1]' ./tmp.json ./user_data/mgm_pair_lists/$exchange-$hyperopt_quote-Top-Volume-StaticPairList.json > ./user_data/mgm-config.json && rm ./tmp.json && jq '.' ./user_data/mgm-config.json"

        '''
        logger.info('üëâ Computing Top Volume Static Pairlist')

        target_file = '$basedir/user_data/mgm_pair_lists/$exchange-$hyperopt_quote-Top-Volume-StaticPairList.json'
        target_file = Template(target_file).substitute(
            basedir=self._basedir,
            exchange=self.config['exchange'].title(),
            hyperopt_quote=self.config['hyperopt']['quote'])

        cmd_str = "$ft_binary test-pairlist -c ./user_data/mgm_tools/$exchange-Retrieve-Top-Volume-StaticPairList.json \
            --quote $hyperopt_quote --print-json | tail -n 1 | jq '.| $exchange_placeholder' > $target_file"

        cmd_str = Template(cmd_str).substitute(
            ft_binary=self.config['ft_binary'],
            exchange=self.config['exchange'].title(),
            hyperopt_quote=self.config['hyperopt']['quote'],
            exchange_placeholder="{exchange: {pair_whitelist: .}}",
            target_file=target_file)

        self.__exec_cmd(cmd_str)

        logger.info(" >>>>>>>>>>>>>>>>>>>>>>>>>")
        logger.info(" üç∫ Don't forget to copy this pairlist to your own ")
        logger.info(" üç∫ mgm-config.json file to start using it!")
        logger.info(" <<<<<<<<<<<<<<<<<<<<<<<<<")

        if os.path.exists(target_file):
            with open(target_file, 'r') as reader:
                print(reader.read())
        else:
            logger.error("ü§∑‚Äç‚ôÇÔ∏è Something happened on the way to heaven üåüü§¶‚Äç‚ôÄÔ∏è")

    def hyperopt(self,
                 timerange: str = None,
                 strategy: str = None,
                 spaces: str = None):
        '''
        HyperOpt Magic. Runs HyperOpt process to find out the most positive settings.

        Args:
            timerange (str, Optional): timerange from/to in format (start-end): yyyymmdd-yyyymmdd
            strategy (str, Optional): Hyper Opt strategy to use. Defaults to MoniGoManiHyperStrategy
            spaces (str, Optional): Spaces (space delimited) to optimize for [default, all, buy, sell, roi, stoploss, etc]
        '''
        logger.info(
            'üëâ Starting HyperOpt run. Keep calm while your computer burns üî•')

        if timerange is None:
            timerange = self.config['timerange']

        if strategy is None:
            strategy = self.config['hyperopt']['strategy']

        if spaces is None:
            spaces = self.config['hyperopt']['spaces']

        cmd = '$ft_binary hyperopt --print-all -s $ho_strategy -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json --hyperopt-loss $ho_loss --spaces $ho_spaces -e $ho_epochs --timerange $timerange'
        cmd = Template(cmd).substitute(
            ft_binary=self.config['ft_binary'],
            ho_strategy=strategy,
            ho_loss=self.config['hyperopt']['loss'],
            ho_spaces=spaces,
            ho_epochs=self.config['hyperopt']['epochs'],
            timerange=timerange)

        self.__exec_cmd(cmd)

        logger.info('üç∫ HyperOpt run ready... ü•µ')

    def hyperopt_show_results(self, epoch: int = 0):
        '''
        Shows the HyperOpt results for given epoch.

        Args:
            epoch (int): The epoch number to show the results from.
        '''
        if epoch == 0:
            logger.error(
                'ü§∑‚Äç‚ôÇÔ∏è Please pass the epoch number through. Hint: hurry hyperopt_show_results --epoch=1337'
            )
            sys.exit(1)

        logger.info('üëâ  Showing HyperOpt results for epoch # {epoch}')

        self.__exec_cmd(f"{self.config['ft_binary']} hyperopt-show -n {epoch}")

    def hyperopt_apply_epoch(self, epoch: int = 0, run: int = 1):
        '''Apply HyperOpt results from given epoch

        Args:
            epoch (int): The epoch number to apply the results from.
            run (int, Optional): Defaults to 1. Run number of hyperopt. First run has different command than second.
        '''
        if epoch == 0:
            logger.error(
                'ü§∑‚Äç‚ôÇÔ∏è Please pass the epoch number through. Hint: hurry hyperopt_apply_epoch --epoch=1337'
            )
            sys.exit(1)

        logger.info(f'üëâ Applying HyperOpt results of epoch # {epoch}')

        if run == 1:
            self.__exec_cmd(
                f"{self.config['ft_binary']} hyperopt-show -n {epoch} -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json --no-header --print-json | tail -n 1 | jq '.' > ./user_data/mgm-config-hyperopt.json"
            )
        else:
            self.__exec_cmd(
                f"{self.config['ft_binary']} hyperopt-show -n {epoch} -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json --no-header --print-json | tail -n 1 | jq '.' > ./tmp.json && jq -s '.[0] * .[1]' ./user_data/mgm-config-hyperopt.json ./tmp.json > ./tmp2.json && rm ./tmp.json ./user_data/mgm-config-hyperopt.json && mv ./tmp2.json ./user_data/mgm-config-hyperopt.json && jq '.' ./user_data/mgm-config-hyperopt.json"
            )

        logger.info(f'üç∫ Hyperopt results of epoch # {epoch} are applied.')

    def backtest(self, timerange: str = None, enable_protections: bool = True):
        '''
        Run a backtest session.

        Args:
            timerange (string, Optional): The target timerange for backtesting. Defaults to None.
            enable_protections (bool, Optional): Whether or not to enable protections. Defaults to True.
        '''
        logger.info('üëâ Start backtesting. Lets see how it turns out!')

        if timerange is None:
            timerange = self.config['timerange']

        cmd = '$ft_binary backtesting -s $ho_strategy -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json --timerange $timerange'

        if enable_protections is True:
            cmd = cmd + " --enable-protections"

        cmd = Template(cmd).substitute(
            ft_binary=self.config['ft_binary'],
            ho_strategy=self.config['hyperopt']['strategy'],
            timerange=timerange)

        self.__exec_cmd(cmd)

        logger.info('üç∫ Backtesting ready... ü§ë')

    def start_trader(self, dry_run: bool = False):
        '''
        Start the trader. Your ultimate goal!

        Args:
            dry_run (bool, Optional): Use dry_run mode. Defaults to False
        '''
        cmd = f"{self.config['ft_binary']} trade -c ./user_data/mgm-config.json -c ./user_data/mgm-config-private.json -c ./user_data/mgm-config-hyperopt.json --strategy {self.config['hyperopt']['strategy']}"

        if dry_run is True:
            cmd = cmd + " --dry-run"

        logger.info('üëâ Starting the trade bot. The real deal ü§ì')

        self.__exec_cmd(cmd)

    def __setup_telegram(self) -> bool:
        '''
        Questionnaire to setup Telegram Bot

        Returns:
            bool: False if no answers are given, True if all went ok.
        '''
        questions = [
            {
                "type": "confirm",
                "message": "Do you want to also setup your Telegram bot? ",
                "name": "proceed_telegram",
                "default": True,
            },
            {
                "type": "confirm",
                "message": "Do you want to enable the Telegram Bot?",
                "name": "enable_telegram",
                "default": True,
                "when": lambda result: result["proceed_telegram"]
            },
            {
                "type":
                "password",
                "name":
                "telegram_token",
                "message":
                "Please enter your Telegram Bot token: ",
                "default":
                "",
                "when":
                lambda result: result["proceed_telegram"] and result[
                    "enable_telegram"]
            },
            {
                "type":
                "input",
                "name":
                "telegram_chat_id",
                "message":
                "Please enter the chat ID: ",
                "default":
                "",
                "when":
                lambda result: result["proceed_telegram"] and result[
                    "enable_telegram"]
            },
        ]

        answers = prompt(questions=questions)

        if answers == {}:
            return False

        if answers.get('proceed_telegram') is True:
            opt = {
                'enable_telegram': answers.get('enable_telegram'),
                'telegram_token': answers.get('telegram_token'),
                'telegram_chat_id': answers.get('telegram_chat_id')
            }

            self._save_telegram_credentials(opt)

        return True

    def _save_exchange_credentials(self, cred: Array):
        '''
        Save exchange credentials to mgm-config-private.json

        Args:
            cred (Array) - list containing values for [exchange,api_key,api_secret]
        '''
        file = open(self._basedir + '/user_data/mgm-config-private.json', )

        data = json.load(file)

        data['exchange'] = {
            "name": cred['exchange'],
            "key": cred['api_key'],
            "secret": cred['api_secret']
        }

        with open(self._basedir + '/user_data/mgm-config-private.json',
                  'w') as outfile:
            json.dump(data, outfile)

        logger.info("üç∫ Exchange settings written to mgm-config-private.json")

    def _save_telegram_credentials(self, opt: Array):
        '''
        Save Telegram bot settings

        Args:
            opt (Array): list containing values for [enable_telegram,telegram_token,telegram_chat_id]
        '''
        file = open(self._basedir + '/user_data/mgm-config-private.json', )

        data = json.load(file)

        data['telegram'] = {
            "enabled": opt['enable_telegram'],
            "token": opt['telegram_token'],
            "chat_id": opt['telegram_chat_id']
        }

        with open(self._basedir + '/user_data/mgm-config-private.json',
                  'w') as outfile:
            json.dump(data, outfile)

        logger.info(
            "üç∫ Telegram bot settings written to mgm-config-private.json")

    @staticmethod
    def __exec_cmd(cmd: str):
        '''
        Executes shell command and logs output as debug output.

        Args:
            cmd (str): The command, sir
        '''
        if cmd is None or cmd == "":
            logger.error(
                'ü§∑‚Äç‚ôÇÔ∏è Please pass a command through. Without command no objective, sir!'
            )
            sys.exit(1)

        logger.debug(cmd)
        p = subprocess.Popen(cmd,
                             shell=True,
                             stdout=subprocess.PIPE,
                             encoding='utf-8')
        output, err = p.communicate()
        logger.debug(output)

    @staticmethod
    def __read_config():
        '''
        Reads config values out of .hurry config file.

        Returns:
            array: Array containing all config key/value pairs. Or returns None.
        '''
        with open(".hurry", "r") as ymlfile:
            cfg = yaml.full_load(ymlfile) or {}

        if 'config' in cfg:
            return cfg['config']

        return None

    @staticmethod
    def __write_config(config: object = None):
        '''Write config-array to .hurry config file. Hooray!

        Args:
            config (object, Optional): The config values to store. Defaults to None.
        '''
        if config is None:
            config = {
                'config': {
                    'install_type': 'docker',
                    'timerange': '20201201-20210316',
                    'exchange': 'binance',
                    'hyperopt': {
                        'strategy': 'MoniGoManiHyperStrategy',
                        'loss': 'UncloggedWinRatioAndProfitRatioLoss',
                        'spaces': 'buy sell',
                        'quote': 'BTC',
                        'epochs': 800
                    }
                }
            }

        with open(r'.hurry', 'w') as file:
            yaml.dump(config, file)

        logger.info("üç∫ Configuration data written to .hurry file")


if __name__ == "__main__":
    fire.Fire(Hurry)
